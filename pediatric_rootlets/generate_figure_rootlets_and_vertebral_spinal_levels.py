#!/usr/bin/env python
#
# This script is used to generate a figure showing the correspondence between spinal levels and vertebrae levels.
# The script also computes a distance from the PMJ to the middle of each spinal level and COV. Results are saved to
# a CSV file.
#
# Usage:
#     python generate_figure_rootlets_vertebrae_spinal_levels.py -i /path/to/data_processed
#
# Authors: Katerina Krejci, Jan Valosek
#

import os
import sys
import glob
import argparse

import pandas as pd
import matplotlib as mpl
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.patheffects as pe

# Initialize dictionaries
SUBJECT_TO_AXIS = {}
SUBJECT_TO_XTICKS = {}
LIST_OF_LEVEL_TYPES = ['rootlets', 'vertebrae']
XOFFSET = {'rootlets': -0.10, 'vertebrae': 0.10}
LEVEL_TYPE_COLOR = {'rootlets': 'red', 'vertebrae': 'green'}
SPINAL_LEVEL_TYPES_TO_LEGEND = {'rootlets': 'spinal', 'vertebrae': 'vertebral'}
FONT_SIZE = 14

AGE_GROUPS = {
    '7-10': range(7, 11),
    '11-14': range(11, 15),
    '15-17': range(15, 18)
}


def get_parser():
    """
    parser function
    """

    parser = argparse.ArgumentParser(
        description='Generate a figure showing the correspondence of spinal and vertebral levels for individual subjects and spinal levels.',
        prog=os.path.basename(__file__).strip('.py')
    )
    parser.add_argument(
        '-i',
        required=True,
        type=str,
        help='Path to the data_processed folder with CSV files for individual subjects and method of level estimation generated by the '
             'inter-rater_variability/02a_rootlets_vertebrae_spinal_levels.py script.'
             'The figure will be saved to the same folder.'
    )
    parser.add_argument(
        '-participants',
        required=True,
        type=str,
        help='Path to the participants.tsv file.'
    )

    return parser


def generate_figure(df, dir_path):
    """
    Generate a figure showing the variability of spinal and vertebral levels for individual subjects and spinal levels.
    :param df: Pandas DataFrame with the data
    :param dir_path: Path to the data_processed folder
    :return: None
    """
    #mpl.rcParams['font.family'] = 'Arial'

    fig = plt.figure(figsize=(14, 6))
    ax = fig.add_subplot()

    subjects = df['subject'].unique()
    group = df['age_group'].unique()

    # how many subjects are in the groups (each subject is in the group only once)
    num_subjects_in_groups = df.groupby('age_group')['subject'].nunique()

    # replace subject_to_axis with subjects:
    SUBJECT_TO_AXIS = {subject: i+1 for i, subject in enumerate(subjects)}
    SUBJECT_TO_XTICKS = {subject: subject for subject in subjects}

    print(SUBJECT_TO_AXIS)

    # Define the background rectangles - for each age group
    rect1 = plt.Rectangle((0.6, 10), num_subjects_in_groups['7-10'], 140, linewidth=1, edgecolor='none', facecolor='orange', alpha=0.10)
    rect2 = plt.Rectangle(((0.6 + num_subjects_in_groups['7-10'] + 0.05), 10), num_subjects_in_groups['11-14'], 140, linewidth=1, edgecolor='none', facecolor='blue', alpha=0.05)
    rect3 = plt.Rectangle(((0.6 + num_subjects_in_groups['7-10'] + num_subjects_in_groups['11-14'] + 0.1), 10), num_subjects_in_groups['15-17']-0.2, 140, linewidth=1, edgecolor='none', facecolor='yellow', alpha=0.10)

    # Get current axes and add the rectangles
    plt.gca().add_patch(rect1)
    plt.gca().add_patch(rect2)
    plt.gca().add_patch(rect3)

    # Adding text inside rectangles
    ax.text(1.3, 16, 'Age 7 - 10', fontsize=8, weight='bold')
    ax.text(4.8, 16, 'Age 11 - 14', fontsize=8, weight='bold')
    ax.text(10.7, 16, 'Age 15 - 17', fontsize=8, weight='bold')


    # Loop across subjects
    for subject in SUBJECT_TO_AXIS.keys():
        subject_age_group = df[df['subject'] == subject]['age_group'].values[0]
        # Loop across spinal level types
        for spinal_level_type in LIST_OF_LEVEL_TYPES:
            # Loop across spinal levels
            for level in df['spinal_level'].unique():
                row = df[(df['subject'] == subject) & (df['spinal_level_type'] == spinal_level_type) & (df['spinal_level'] == level)]

                # Skip if the row is empty
                if row.empty:
                    continue

                # Get the distance from PMJ and height of spinal level
                start = float(row['distance_from_pmj_end'])
                height = float(row['height'])

                # Plot rectangle for the subject, spinal and vertebral levels
                ax.add_patch(
                    patches.Rectangle(
                        (SUBJECT_TO_AXIS[subject] + XOFFSET[spinal_level_type], start),      # (x,y)
                        0.10,            # width
                        height,         # height
                        color=LEVEL_TYPE_COLOR[spinal_level_type],
                        alpha=0.58,
                    ))

                # Add level number into each rectangle
                ax.text(
                    SUBJECT_TO_AXIS[subject] + XOFFSET[spinal_level_type] + 0.05,     # x
                    start,                                                  # y
                    int(level),
                    horizontalalignment='center',
                    verticalalignment='center',
                    fontsize=8,
                    color='white',
                    path_effects=[pe.withStroke(linewidth=1, foreground='black')]
                )

                # Add mean value
                ax.plot(
                    [SUBJECT_TO_AXIS[subject] + XOFFSET[spinal_level_type], SUBJECT_TO_AXIS[subject] + XOFFSET[spinal_level_type] + 0.1],
                    [start+height/2, start+height/2],
                    color='black',
                    linewidth=1,
                    alpha=0.5,
                    linestyle='dashed',
                )

    # Adjust the axis limits
    ax.set_xlim(0.5, 14.5)
    ax.set_ylim(min(df['distance_from_pmj_end'].min(), df['distance_from_pmj_start'].min())*0.9,
                max(df['distance_from_pmj_end'].max(), df['distance_from_pmj_start'].max())*0.80)

    # Set axis labels
    ax.set_xlabel('Subject', fontsize=FONT_SIZE)
    ax.set_ylabel('Distance from PMJ [mm]', fontsize=FONT_SIZE)

    # Set x-axis ticklabels based on the SUBJECT_TO_AXIS dictionary
    ax.set_xticks(list(SUBJECT_TO_AXIS.values()))
    ax.set_xticklabels(list(SUBJECT_TO_XTICKS.values()), fontsize=FONT_SIZE-4)

    # Set size of y-axis ticks
    ax.tick_params(axis='y', labelsize=FONT_SIZE-4)

    # Set y-axis ticks to every 10 mm
    ax.set_yticks(range(10, 170, 10))

    # Reverse ylim
    ax.set_ylim(ax.get_ylim()[::-1])

    # Add horizontal grid
    ax.grid(axis='y', alpha=0.2)
    ax.set_axisbelow(True)

    # Add a single line legend with opacity 0.5
    ax.legend(handles=[
        patches.Patch(color=LEVEL_TYPE_COLOR[spinal_level_type], label=SPINAL_LEVEL_TYPES_TO_LEGEND[spinal_level_type], alpha=0.5)
        for spinal_level_type in LIST_OF_LEVEL_TYPES
    ], ncol=2, loc='upper center', bbox_to_anchor=(0.5, 1.12))

    # Add a single line legend with opacity 0.5
    leg1 = ax.legend(handles=[
        patches.Patch(color=LEVEL_TYPE_COLOR[spinal_level_type], label=SPINAL_LEVEL_TYPES_TO_LEGEND[spinal_level_type],
                      alpha=0.5)
        for spinal_level_type in LIST_OF_LEVEL_TYPES
    ], ncol=2, loc='upper center', bbox_to_anchor=(0.5, 1.12))
    ax.add_artist(leg1)

    # Update the legend title font size
    plt.setp(ax.get_legend().get_title(), fontsize=FONT_SIZE-2)

    # Add title and move it slightly up
    ax.set_title('Spinal vs. Vertebral Levels', pad=40)        # pad=20

    # Remove spines
    ax.spines['right'].set_visible(False)
    ax.spines['left'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.spines['bottom'].set_visible(True)

    plt.tight_layout()

    # Save the figure
    fname_figure = 'figure_spinal_levels_vs_vertebral_levels_groups.png'
    fig.savefig(os.path.join(dir_path, fname_figure), dpi=300)
    print(f'Figure saved to {os.path.join(dir_path, fname_figure)}')


def main():
    # Parse the command line arguments
    parser = get_parser()
    args = parser.parse_args()

    dir_path = os.path.abspath(args.i)

    if not os.path.isdir(dir_path):
        print(f'ERROR: {args.i} does not exist.')
        sys.exit(1)

    df_participants = pd.read_csv(args.participants, sep='\t')
    participants_age = df_participants[['participant_id', 'age']]

    # Get all the CSV files in the directory generated by the 02a_rootlets_to_spinal_levels.py script
    csv_files = glob.glob(os.path.join(dir_path, '**', '*pmj_distance_*[vertebral|rootlets].csv'), recursive=True)

    # if csv_files is empty, exit
    if len(csv_files) == 0:
        print(f'ERROR: No CSV files found in {dir_path}')

    # Initialize an empty list to store the parsed data
    parsed_data = []

    # Loop across CSV files and aggregate the results into pandas dataframe
    for csv_file in csv_files:
        df_file = pd.read_csv(csv_file)
        parsed_data.append(df_file)

    # Combine list of dataframes into one dataframe
    df = pd.concat(parsed_data)
    df['age'] = df['fname'].apply(lambda x: participants_age[participants_age['participant_id'] == x[:7]]['age'].values[0])
    df['age_group'] = df['age'].apply(
        lambda x: '7-10' if x in AGE_GROUPS['7-10'] else '11-14' if x in AGE_GROUPS['11-14'] else '15-17')

    # Extract rootlets or vertebrae level type from the fname and add it as a column
    df['spinal_level_type'] = df['fname'].apply(
        lambda x: 'rootlets' if x.split('_')[2].split('-')[1] == 'rootlets' else 'vertebrae')

    # Extract subjectID from the fname and add it as a column
    df['subject'] = df['fname'].apply(lambda x: x.split('_')[0])

    # Extract spinal level (cervical 2-8) and vertebral level (1-7)
    df = df[((df['spinal_level_type'] == 'rootlets') & (df['spinal_level'].isin([2, 3, 4, 5, 6, 7, 8]))) |
            ((df['spinal_level_type'] == 'vertebrae') & (df['spinal_level'].isin([1, 2, 3, 4, 5, 6, 7])))]

    # Define the custom order
    age_group_order = ['7-10', '11-14', '15-17']

    # Convert the 'age_group' column to a categorical type with the custom order
    df['age_group'] = pd.Categorical(df['age_group'], categories=age_group_order, ordered=True)

    # Sort the DataFrame based on the 'age_group' column
    df = df.sort_values('age_group').reset_index(drop=True)

    # from df remove subjects 121 and 125
    df = df[~df['subject'].isin(['sub-121', 'sub-125'])]

    # Generate the figure
    generate_figure(df, dir_path)


if __name__ == '__main__':
    main()

